{
    "summary": "This code defines a function to iterate through source files, generate target directories and write comments using Jinja2 templates. It also includes classes for adding content to documents, generating web page templates, setting up file loader, providing functions to write content to an output path and retrieve render parameters, updating data related to files and their contents in the database, and includes helper functions. The code processes data, writes summaries as JSON files, renders templates, copies static pages, generates webpage elements using subprocesses, and creates webpages.",
    "details": [
        {
            "comment": "This code sets environment variables for the OpenAI API, imports necessary modules, and defines constants. It also includes a function to check if a file is empty. The code also utilizes beartype, cache_db_context, identify_utils, and custom_doc_writer modules for various functionalities. It uses split_dict_into_chunks from slice_utils to split dictionaries into chunks. It uses parse for parsing arguments and construct_llm_and_write_code_comment for writing code comments. It also utilizes iterate_source_dir_and_generate_to_target_dir for reading files, and write_file for writing file contents.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":0-38",
            "content": "# os.environ[\"OPENAI_API_KEY\"] = \"any\"\n# os.environ[\"OPENAI_API_BASE\"] = \"http://0.0.0.0:8000\"\n# os.environ[\"BETTER_EXCEPTIONS\"] = \"1\"\n# TODO: add shared context while spliting code into chunks\nimport os\nfrom typing import Literal, Optional, Union #, OrderedDict\nimport uuid\nimport json\nfrom slice_utils import split_dict_into_chunks\nimport parse\nimport shutil\nimport custom_doc_writer\nCODE_LOCATION_FORMAT = '\"{code_path}\":{line_start:d}-{line_end:d}'\nDATA_SLICE_LENGTH = 100\nfrom beartype import beartype\nfrom cache_db_context import (\n    CacheContextManager,\n    CacheManager,\n    SourceIteratorAndTargetGeneratorParam,  # type:ignore\n    TargetGeneratorParameter,\n    iterate_source_dir_and_generate_to_target_dir,\n    read_file,\n    write_file,\n)\nfrom custom_doc_writer import (\n    construct_llm_and_write_code_comment,  # type:ignore\n    parse_arguments,\n)\nfrom identify_utils import get_language_id_from_filename\n@beartype\ndef file_empty(fpath: str):\n    assert os.path.exists(fpath), \"File %s does not exist\" % fpath\n    with open(fpath, \"r\") as f:"
        },
        {
            "comment": "The code contains a series of functions. The first function, \"file_empty\", checks if a file is empty and returns True if it is, or False otherwise. Next, the \"dirpath_and_fpath_walker\" function uses os.walk to iterate over all directories and files in the specified directory path, and yields directory and file paths for which the file is not empty. The \"get_source_iterator_and_target_generator_param_from_document_dir\" function constructs the paths to source directory, target directory, and database file from the document directory path and optional relpaths for code, output, and database files. Lastly, the \"generate_comment_path\" function generates a comment file path with a random UUID for each comment.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":39-75",
            "content": "        content = f.read().strip()\n        if content == \"\":\n            return True\n    return False\n@beartype\ndef dirpath_and_fpath_walker(dir_path: str):\n    for dirpath, _, filenames in os.walk(dir_path):\n        for filename in filenames:\n            fpath = os.path.join(dirpath, filename)\n            if not file_empty(fpath):\n                yield dirpath, fpath\n@beartype\ndef get_source_iterator_and_target_generator_param_from_document_dir(\n    document_dir: str,\n    code_relpath: str = \"src\",\n    output_relpath: str = \"doc\",\n    db_relpath: str = \"cache_db.json\",\n):\n    source_dir_path = os.path.join(document_dir, code_relpath)\n    target_dir_path = os.path.join(document_dir, output_relpath)\n    db_path = os.path.join(document_dir, db_relpath)\n    param = SourceIteratorAndTargetGeneratorParam(\n        source_dir_path=source_dir_path,\n        target_dir_path=target_dir_path,\n        db_path=db_path,\n    )\n    return param\n@beartype\ndef generate_comment_path(param: TargetGeneratorParameter):\n    comment_rel_path = str(uuid.uuid4()) + \".json\""
        },
        {
            "comment": "This code defines a function `scan_code_dir_and_write_to_comment_dir` that takes a document directory as input and iterates through the source files, generating target directories, and writing code comments to corresponding comment directories. It uses Jinja2 templates and a SearchIndexData class for data manipulation. The function returns a parameter object containing source iterator and target generator parameters from the given document directory.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":76-115",
            "content": "    comment_path = os.path.join(param.target_dir_path, comment_rel_path)\n    return comment_path\n@beartype\ndef scan_code_dir_and_write_to_comment_dir(document_dir: str):\n    param = get_source_iterator_and_target_generator_param_from_document_dir(\n        document_dir\n    )\n    iterate_source_dir_and_generate_to_target_dir(\n        param,\n        dirpath_and_fpath_walker,\n        generate_comment_path,\n        construct_llm_and_write_code_comment,\n    )\n    return param\nfrom jinja2 import Environment, FileSystemLoader, Template\n@beartype\nclass SearchIndexData(dict):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.counter = 0\n        self.file_id: Optional[int] = None\n    def insert_filepath_and_summary(self, file_id: int, filepath: str, summary: str):\n        self.file_id = file_id\n        self.insert(\n            content=filepath,\n            type=\"filepath\",\n        )\n        self.insert(\n            content=summary,\n            type=\"summary\",\n        )\n    def insert_code_and_comment(self, code: str, comment: str, location: str):"
        },
        {
            "comment": "This code defines a class with an \"insert\" method that adds content of different types (filepath, summary, comment, code) to a document. It also includes a function, \"render_document_webpage\", which takes parameters like directory paths and URLs to generate a web page template for the document using Jinja2 templating engine.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":116-151",
            "content": "        self.insert(content=code, type=\"code\", location=location)\n        self.insert(\n            content=comment,\n            type=\"comment\",\n        )\n    def insert(\n        self,\n        content: str,\n        type: Literal[\"filepath\", \"summary\", \"comment\", \"code\"],\n        location: Optional[str] = None,\n    ):\n        assert isinstance(self.file_id, int)\n        self[self.counter] = dict(\n            file_id=self.file_id,\n            content=content,\n            type=type,\n            **(dict(location=location) if location else {}),\n        )\n        self.counter += 1\n@beartype\ndef render_document_webpage(\n    document_dir_path: str,\n    param: SourceIteratorAndTargetGeneratorParam,\n    repository_url: str,\n    template_dir: str = \".\",\n    template_filename: str = \"website_template.html.j2\",\n    output_filename: str = \"index.html\",\n    url_prefixs: list[str] = [\"https://github.com/\", \"https://gitee.com/\"],\n    # url_prefix: str = \"https://github.com/\",\n):\n    @beartype\n    def load_template() -> Template:\n        # Load the template from file"
        },
        {
            "comment": "This code sets up a file loader and environment for rendering a template, provides functions to write content to an output path and retrieve render parameters, and includes helper functions for stripping paths.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":152-179",
            "content": "        file_loader = FileSystemLoader(\n            template_dir\n        )  # Replace 'path_to_templates_directory' with the actual path\n        env = Environment(loader=file_loader)\n        template = env.get_template(\n            template_filename\n        )  # Replace 'sitemap_template.html' with the actual template file name\n        return template\n    @beartype\n    def write_to_output_path(content: str):\n        output_path = os.path.join(document_dir_path, output_filename)\n        write_file(output_path, content)\n    @beartype\n    def get_template_render_params() -> dict[str, Union[dict, str]]:\n        data = SearchIndexData()\n        file_mapping: dict[int, dict[str, Union[str, int]]] = {}\n        @beartype\n        def strip_path_prefix(path: str):\n            return path[len(param.source_dir_path) :]\n        @beartype\n        def strip_location(location: str):\n            result = parse.parse(CODE_LOCATION_FORMAT, location)\n            assert isinstance(result, parse.Result)\n            stripped_path = strip_path_prefix(result[\"code_path\"])"
        },
        {
            "comment": "The code defines functions for updating data related to files and their contents. The `update_data_by_target_data` function inserts the file path and summary into the database, and then iterates through each detail of the target data (likely containing code and comment) to insert them into the database as well. The `update_data_and_file_mapping` function maps a file ID to its corresponding file path, entry ID, and language ID by updating the `file_mapping` dictionary with this information.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":180-205",
            "content": "            return f\"{stripped_path}:{result['line_start']+1}-{result['line_end']+1}\"\n        @beartype\n        def update_data_by_target_data(\n            target_data: dict, file_id: int, source_relative_path: str\n        ):\n            data.insert_filepath_and_summary(\n                file_id=file_id,\n                filepath=source_relative_path,\n                summary=target_data[\"summary\"],\n            )\n            for detail in target_data[\"details\"]:\n                data.insert_code_and_comment(\n                    code=detail[\"content\"],\n                    comment=detail[\"comment\"],\n                    location=strip_location(detail[\"location\"]),\n                )\n        @beartype\n        def update_data_and_file_mapping(\n            manager: CacheManager, record: dict, file_id: int, source_relative_path: str\n        ):\n            file_mapping[file_id] = dict(\n                filepath=source_relative_path,\n                entry_id=data.counter,\n                language_id=get_language_id_from_filename(source_relative_path),"
        },
        {
            "comment": "This code snippet is part of a Python script responsible for assembling render parameters and iterating over source directory files. It retrieves data from a database, constructs render parameters using this data, and handles files within the source directory. The `get_record_target_path_and_hash` function gets the target path and hash for a record, while `read_file` reads the contents of a file. The `assemble_render_params` function creates a dictionary of render parameters, including data, repository URL, file mapping, and partial repository URL. The `iterate_source_dir_and_assemble_render_params` function uses a database manager to access source path list and potentially return one result if there's only one file present.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":206-229",
            "content": "            )\n            target_path, _ = manager.get_record_target_path_and_hash(record)\n            target_data = json.loads(read_file(target_path))\n            update_data_by_target_data(target_data, file_id, source_relative_path)\n        def assemble_render_params():\n            partial_repository_url = repository_url\n            for it in url_prefixs:\n                partial_repository_url = partial_repository_url.replace(it, \"\").strip(\n                    \"/\"\n                )\n            render_params = dict(\n                datadict=data,\n                repository_url=repository_url,\n                file_mapping=file_mapping,\n                partial_repository_url=partial_repository_url,\n            )\n            return render_params\n        def iterate_source_dir_and_assemble_render_params():\n            # if only have one file, we should return one\n            with CacheContextManager(param.db_path) as manager:\n                source_path_list = [\n                    sp for _, sp in dirpath_and_fpath_walker(param.source_dir_path)"
        },
        {
            "comment": "This code is a recursive function that iterates over source files in a directory, sorts their paths to reduce git folder size, and updates the corresponding record with the file's information. It uses a manager object to get records by computing source hash and then calls `update_data_and_file_mapping` function. Finally, it returns the result of `assemble_render_params()`. The code also includes a `strip_quote()` helper function that strips leading and trailing quotes from a string and a TODO note about mapping source file paths to documentation JSON and adding a mode for indexing to hide search bar and render single file left-right comparison only.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":230-255",
            "content": "                ]\n                source_path_list.sort()  # to reduce git folder size\n                for file_id, source_path in enumerate(source_path_list):\n                    source_relative_path = strip_path_prefix(source_path)\n                    record, _ = manager.get_record_by_computing_source_hash(source_path)\n                    if record:\n                        update_data_and_file_mapping(\n                            manager, record, file_id, source_relative_path\n                        )\n            return assemble_render_params()\n        return iterate_source_dir_and_assemble_render_params()\n    def strip_quote(s: str):\n        s = s.strip()\n        if s[0] == s[-1]:\n            if s[0] in ['\"', \"'\"]:\n                return s[1:-1].strip()\n        return s.strip()\n    @beartype\n    def write_render_params(render_params: dict):\n        # TODO: mapping source file path to documentation json\n        # TODO: add mode of index to hide search bar and render single file left-right comparison only"
        },
        {
            "comment": "The code is filtering out comments and summaries from the 'datadict' dictionary. It then splits the filtered data into chunks and writes each chunk as a separate JSON file in the \"data\" directory within the given document directory. This seems to be part of a larger process that handles splitting, processing, and writing data for documentation purposes.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":256-285",
            "content": "        datadict = render_params[\"datadict\"]\n        metadata = dict()\n        metadata[\"url\"] = dict(\n            full=render_params[\"repository_url\"],\n            partial=render_params[\"partial_repository_url\"],\n        )\n        metadata[\"file_mapping\"] = render_params[\"file_mapping\"]\n        metadata[\"project_name\"] = render_params[\"partial_repository_url\"].split(\"/\")[\n            -1\n        ]\n        split_count = 0\n        # datadict_split = {}\n        datadict = {\n            k: v\n            if (v[\"type\"] not in [\"comment\", \"summary\"])\n            else {\n                \"file_id\": v[\"file_id\"],\n                \"content\": strip_quote(v[\"content\"]),\n                \"type\": v[\"type\"],\n            }\n            for k, v in datadict.items()\n        }\n        data_dir = os.path.join(document_dir_path, \"data\")\n        if not os.path.exists(data_dir):\n            os.mkdir(data_dir)\n        for chunk in split_dict_into_chunks(datadict, DATA_SLICE_LENGTH):\n            write_file(\n                os.path.join(data_dir, f\"{split_count}.json\"),"
        },
        {
            "comment": "The code defines a function `render_template` that takes a `Template` object, gets template render parameters using `get_template_render_params()`, writes the render parameters to a file using `write_render_params()`, and then renders the template with the parameters. It also includes functions `copy_static_pages()` for copying static HTML files to the document directory and `write_gitignore()` for writing a git ignore file in the document directory.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":286-311",
            "content": "                json.dumps(chunk, indent=4, ensure_ascii=False),\n            )\n            split_count += 1\n        metadata[\"split_count\"] = split_count\n        write_file(\n            os.path.join(document_dir_path, \"metadata.json\"),\n            json.dumps(metadata, indent=4, ensure_ascii=False),\n        )\n    @beartype\n    def render_template(template: Template):\n        render_params = get_template_render_params()\n        write_render_params(render_params)\n        # do something else, like writing to files.\n        # ret = template.render(**render_params)\n        # return ret\n    def copy_static_pages():\n        script_base_dir = os.path.split(__file__)[0]\n        static_pages_dir = os.path.join(script_base_dir, \"static_pages\")\n        for fname in [\"index.html\", \"codeview.html\"]:\n            # for fname in os.listdir(static_pages_dir):\n            shutil.copy(os.path.join(static_pages_dir, fname), document_dir_path)\n    def write_gitignore():\n        with open(os.path.join(document_dir_path, \".gitignore\"), \"w+\") as f:"
        },
        {
            "comment": "This code defines a function `run_subprocess` that executes a command-line interface (CLI) and exits if the exit code is not 0. It also includes a `render_to_output_path()` function that loads a template, renders it, copies static pages, writes .gitignore, and potentially calls another function to write content to an output path. The main function parses arguments, sets custom parameters, scans code directory, and writes results to a comment directory, but the webpage creation is still pending.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":312-344",
            "content": "            f.write(\n                \"!.gitignore\\n!*\\n!*/*\\ncache_db.json\\ncache_tree.json\\nvector_cache\\n\"\n            )\n            # f.write(\"!.gitignore\\n!*\\n!*/*\\ncache_db.json\\n\")\n    def render_to_output_path():\n        template = load_template()\n        render_template(template)\n        copy_static_pages()\n        write_gitignore()\n        # content = render_template(template)\n        # write_to_output_path(content)\n    render_to_output_path()\nimport subprocess\ndef run_subprocess(cli: str):\n    print(\"running:\", cli)\n    excode = subprocess.check_call(cli, shell=True)\n    if excode != 0:\n        exit(excode)\ndef main():\n    (document_dir_path, repository_url) = parse_arguments()\n    project_name = repository_url.split(\"/\")[-1]\n    custom_doc_writer.CUSTOM_DOC_WRITER_PARAMS[\"location_prefix\"] = document_dir_path\n    custom_doc_writer.CUSTOM_DOC_WRITER_PARAMS[\"project_name\"] = project_name\n    param = scan_code_dir_and_write_to_comment_dir(document_dir_path)\n    # not done yet. we have to create the webpage."
        },
        {
            "comment": "This code is calling multiple Python scripts to generate webpage titles, a site map, and visualize the folder hierarchy of a given document directory. It uses subprocesses to run these scripts in separate processes.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":345-354",
            "content": "    render_document_webpage(document_dir_path, param, repository_url)\n    run_subprocess(\n        f\"python3.9 -u tree_markdown_view_folder_hierarchy/main_recursive.py -s '{document_dir_path}'\"\n    )\n    run_subprocess(f\"python3.9 -u title_generator/main.py -s '{document_dir_path}'\")\n    run_subprocess(f\"python3.9 -u sitemap_generator/main.py -s '{document_dir_path}'\")\nif __name__ == \"__main__\":\n    main()"
        }
    ]
}