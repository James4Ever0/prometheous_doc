{
    "summary": "This code creates a progress bar, redirects output, differentiates between cached and processed files, and handles progress tracking with stdbuf. It runs Python scripts, records errors, adds progress updates, and prints total execution time in natural language format.",
    "details": [
        {
            "comment": "This code is for creating a progress bar and redirecting stdout to a buffered output window. It differentiates between cached and processed files, retrieves processing time (if available), and uses average time if not. The code also imports necessary libraries like asyncio, parse, Textual, and threading. There are two TODOs mentioning additions for recursive document generation and using a simple timer to produce total processing time and file counts. The class VisualIgnoreApp is inherited from App, with custom initialization parameters error_container and program_args.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/stdout_redirect_progress/main_once.py\":0-40",
            "content": "# redirect stdout to some buffered output window, and show a progress bar below.\n# differentiate between \"cached\" file and \"processed\" file\n# you may retrieve \"cached\" file processing time from somewhere else.\n# if failed to retrieve stored processing time, use average one instead.\n# TODO: add this to recursive document generator.\n# TODO: before that, just use a simple timer for producing total processing time and count files, in size, count and lines.\nimport asyncio\nimport parse\nfrom textual.app import App, ComposeResult\nfrom textual.widgets import Log, ProgressBar\n# import textual\nfrom threading import Lock\nlock = Lock()\nINTERVAL = 0.1\nimport shutil\nimport textwrap\ndef wrap_text(text):\n    # Get the terminal width\n    terminal_width, _ = shutil.get_terminal_size()\n    tw = terminal_width - 8\n    if tw < 8:\n        tw = terminal_width\n    wrapped_text = textwrap.fill(text, width=tw)\n    return wrapped_text.rstrip()\nclass VisualIgnoreApp(App):\n    \"\"\"A Textual app to visualize\"\"\"\n    def __init__(self, error_container: list, program_args: list[str], *args, **kwargs):"
        },
        {
            "comment": "The code initializes the main class with necessary attributes, defines a progress function to update logs and exit the program, composes child widgets for the application, and sets an interval for running the progress function. It also includes a TODO note to run the document processor in a separate process.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/stdout_redirect_progress/main_once.py\":41-72",
            "content": "        super().__init__(*args, **kwargs)\n        self.mylog = Log(max_lines=10000)\n        self.prog = ProgressBar()\n        self.program_args = program_args\n        self.error_container = error_container\n        # self.prog.styles.width=\"100%\"\n        self.prog.styles.align_horizontal = \"center\"\n        # self.prog.update(total=100, progress=0)\n    async def progress(self):\n        locked = lock.acquire(blocking=False)\n        if locked:\n            self.mylog.clear()\n            await main(self.mylog, self.prog, self.error_container, self.program_args)\n            self.exit()\n            # lock.release()\n    def compose(self) -> ComposeResult:\n        \"\"\"Create child widgets for the app.\"\"\"\n        return [self.mylog, self.prog]\n    def on_mount(self) -> None:\n        # await self.progress()\n        # self.exit()\n        self.timer = self.set_interval(INTERVAL, self.progress)\n# mylog = textual.widgets.Log(max_lines = ...)\n# mybar = textual.widgets.ProgressBar(total=100, show_eta=...)\n# mylog.write()\n# TODO: run the document processor in a separate process."
        },
        {
            "comment": "This code snippet is responsible for parsing data received from a separate process, line by line. It uses the stdbuf command to redirect both output and error streams of a Python script execution. The parse_line function extracts progress and total values from each line following a specific format. read_stderr function reads lines from the error stream until it encounters an empty byte, indicating EOF. read_stdout function parses lines from the standard output stream, keeping track of the total count of lines processed so far, likely for progress tracking purposes.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/stdout_redirect_progress/main_once.py\":73-105",
            "content": "# TODO: parse the data received from the separate process, line by line.\n# TODO: if the data starts with something special, we would read and parse the whole line and update progress\n# this is sick.\n# cmd = [\"python3.9\", \"test.py\"]\n# cmd = [\"stdbuf\", \"-o0\", \"-e0\", \"bash\", \"-c\", \"python3.9 test.py 2>&1\"]\ncmd = [\"stdbuf\", \"-o0\", \"-e0\", \"python3.9\", \"test.py\"]\n# cmd = [\"bash\", \"-c\", \"python3.9 test.py 2>&1\"]\nline_format = \"PROCESSING PROGRESS: {progress:d}/{total:d}\"\ndef parse_line(line: str):\n    parsed = parse.parse(line_format, line)\n    if parsed:\n        return parsed[\"progress\"], parsed[\"total\"]\n    return None\nasync def read_stderr(proc, error_container):\n    while True:\n        mbyte = await proc.stderr.readline()  # type:ignore\n        # mbyte = await proc.stderr.read(1)  # type:ignore\n        error_container.append(mbyte.decode())\n        if mbyte == b\"\":\n            break\nasync def read_stdout(proc, mylog, prog):\n    # line_position = 0\n    # line_content = \"\"\n    # mtime = []\n    mtotal_count  =-1\n    while True:"
        },
        {
            "comment": "The code reads a line from the process's stdout, checks if it is empty, and if not, decodes and trims the content. It then writes the trimmed content to a log file after wrapping the text. If the content starts with \">>>> \", it parses the line and updates the progress based on the parsed values.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/stdout_redirect_progress/main_once.py\":106-130",
            "content": "        mbyte = await proc.stdout.readline()  # type:ignore\n        # mbyte = await proc.stdout.read(20)  # type:ignore\n        # mbyte = await proc.stdout.read(1)  # type:ignore\n        if mbyte == b\"\":\n            break\n        else:\n            line_content = mbyte.decode(\"utf-8\").rstrip()\n            # print(content)\n            mylog.write_line(wrap_text(line_content))\n            # mylog.refresh()\n            # continue\n            # if mbyte == b\"\\n\":\n            #     line_position = 0\n            #     # try to parse line content.\n            #     mylog.write(\"\\n\")\n            # mylog.write_line(line_content)\n            if line_content.startswith(\">>>> \"):\n                #     mtime.append(datetime.datetime.now())\n                mline = line_content[5:]\n                ret = parse_line(mline)\n                if ret is not None:\n                    ret_total, ret_prog = ret[1], ret[0]\n                    if ret_total != mtotal_count:\n                        mtotal_count = ret_total\n                        prog.update(total=ret_total, progress=ret_prog)"
        },
        {
            "comment": "This code is creating a subprocess to execute a Python script and redirecting both stdout and stderr to separate tasks for reading. It also advances the progress bar based on parsed progress.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/stdout_redirect_progress/main_once.py\":131-152",
            "content": "                        continue\n                    steps = ret_prog - prog.progress\n                    if steps > 0:\n                        prog.advance(steps)\n                    else:\n                        prog.update(total=ret_total, progress=ret_prog)\n                mylog.write_line(\"parsed progress? \" + str(ret))\nasync def main(mylog, prog, error_container, program_args):\n    # proc = await asyncio.create_subprocess_shell(\n    proc = await asyncio.create_subprocess_exec(\n        *program_args,  # stdout=asyncio.subprocess.PIPE\n        # UNBUFFERED FLAG: -u\n        # \"bash -c 'python3.9 -u test_no_patch.py 2>&1'\",\n        stdout=asyncio.subprocess.PIPE,\n        stderr=asyncio.subprocess.PIPE\n        # \"python3.9 -u test_no_patch.py\", stdout=asyncio.subprocess.PIPE\n        # \"python3.9 test.py\", stdout=asyncio.subprocess.PIPE\n    )  # how to handle the stderr now? we may merge the altogether.\n    t1 = asyncio.create_task(read_stdout(proc, mylog, prog))\n    t2 = asyncio.create_task(read_stderr(proc, error_container))"
        },
        {
            "comment": "Code snippet is part of an asynchronous Python program that runs a subprocess and handles its stdout and stderr output. It checks the return code of the subprocess and prints success or error message accordingly. The script also ensures the Python script is run with unbuffered mode (-u flag). It records the execution time and stores the return code in a container, which can be used for further processing or exceptions.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/stdout_redirect_progress/main_once.py\":153-186",
            "content": "    # task1 = asyncio.create_task(read_stdout(proc, mylog))\n    # task2 = asyncio.create_task(read_stderr(proc))\n    await asyncio.gather(t1, t2)\n    # await asyncio.gather(task1, task2)\n    retcode = await proc.wait()\n    error_container.insert(0, retcode)\n    if retcode != 0:\n        print(f\"Error: subprocess returned {retcode}\")\n    else:\n        print(f\"Success: subprocess returned {retcode}\")\nimport sys\nimport time\nimport humanize\nif __name__ == \"__main__\":\n    split_ind = sys.argv.index(\"--\")\n    args = sys.argv[split_ind + 1 :]\n    if \"python\" in args or \"python3.9\" in args:\n        assert \"-u\" in args, \"Python script must be run with -u flag (unbuffered)\"\n    error_container = []\n    app = VisualIgnoreApp(error_container, args)\n    start_time = time.time()\n    app.run()\n    end_time = time.time()\n    total_time = end_time - start_time\n    # breakpoint()\n    retcode = error_container[0]\n    if retcode != 0:\n        raise Exception(\n            \"\\n\".join(\n                [\"Error: subprocess returned\", str(retcode)]"
        },
        {
            "comment": "This code is adding a progress update to the error container if there was an error, and then printing the total time taken if the execution exited successfully. It uses the humanize module to format the time output in a natural language-like manner.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/stdout_redirect_progress/main_once.py\":187-193",
            "content": "                + error_container[1:]\n                + [\"total time:\", humanize.naturaltime(total_time).split(\" ago\")[0]]\n            )\n        )\n    else:\n        print(\"exit successfully\")\n        print(\"total time:\", humanize.naturaltime(total_time).split(\" ago\")[0])"
        }
    ]
}