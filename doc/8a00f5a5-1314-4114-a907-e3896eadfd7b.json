{
    "summary": "This code imports libraries, defines classes and functions for walking through directories, generating comment paths, iterating source directories, and generating output in target directories. It utilizes Jinja2 templates for rendering files, serves as a recursive document writer and webpage renderer using templates from specified directories, and generates JSON chunks from dictionaries, saving them into separate files.",
    "details": [
        {
            "comment": "This code imports necessary libraries and modules, sets environment variables, defines constants, and includes a function dirpath_and_fpath_walker that walks through directories, collecting file paths for processing. The main purpose of this code seems to be organizing file paths and potentially preparing them for further processing or analysis.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":0-36",
            "content": "# os.environ[\"OPENAI_API_KEY\"] = \"any\"\n# os.environ[\"OPENAI_API_BASE\"] = \"http://0.0.0.0:8000\"\n# os.environ[\"BETTER_EXCEPTIONS\"] = \"1\"\nimport os\nfrom typing import Literal, Optional, OrderedDict, Union\nimport uuid\nimport json\nfrom slice_utils import split_dict_into_chunks\nimport parse\nimport shutil\nimport custom_doc_writer\nCODE_LOCATION_FORMAT = '\"{code_path}\":{line_start:d}-{line_end:d}'\nDATA_SLICE_LENGTH = 100\nfrom beartype import beartype\nfrom cache_db_context import (\n    CacheContextManager,\n    CacheManager,\n    SourceIteratorAndTargetGeneratorParam,  # type:ignore\n    TargetGeneratorParameter,\n    iterate_source_dir_and_generate_to_target_dir,\n    read_file,\n    write_file,\n)\nfrom custom_doc_writer import (\n    construct_llm_and_write_code_comment,  # type:ignore\n    parse_arguments,\n)\nfrom identify_utils import get_language_id_from_filename\n@beartype\ndef dirpath_and_fpath_walker(dir_path: str):\n    for dirpath, _, filenames in os.walk(dir_path):\n        for filename in filenames:\n            fpath = os.path.join(dirpath, filename)"
        },
        {
            "comment": "This code defines functions for generating comment paths, iterating source directories, and generating output in target directories. The get_source_iterator_and_target_generator_param_from_document_dir function sets up the necessary file paths based on document directory and default values. The generate_comment_path function generates a unique filename and combines it with the target directory path. The scan_code_dir_and_write_to_comment_dir function retrieves parameters, iterates over source directories, and generates output to target directories using the previous functions.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":37-71",
            "content": "            yield dirpath, fpath\n@beartype\ndef get_source_iterator_and_target_generator_param_from_document_dir(\n    document_dir: str,\n    code_relpath: str = \"src\",\n    output_relpath: str = \"doc\",\n    db_relpath: str = \"cache_db.json\",\n):\n    source_dir_path = os.path.join(document_dir, code_relpath)\n    target_dir_path = os.path.join(document_dir, output_relpath)\n    db_path = os.path.join(document_dir, db_relpath)\n    param = SourceIteratorAndTargetGeneratorParam(\n        source_dir_path=source_dir_path,\n        target_dir_path=target_dir_path,\n        db_path=db_path,\n    )\n    return param\n@beartype\ndef generate_comment_path(param: TargetGeneratorParameter):\n    comment_rel_path = str(uuid.uuid4()) + \".json\"\n    comment_path = os.path.join(param.target_dir_path, comment_rel_path)\n    return comment_path\n@beartype\ndef scan_code_dir_and_write_to_comment_dir(document_dir: str):\n    param = get_source_iterator_and_target_generator_param_from_document_dir(\n        document_dir\n    )\n    iterate_source_dir_and_generate_to_target_dir("
        },
        {
            "comment": "This code defines a class `SearchIndexData` that extends from `dict` and has methods to insert file paths, summaries, codes, and comments. The class also keeps track of the current file id and a counter for insertions. It utilizes Jinja2 templates for rendering files.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":72-112",
            "content": "        param,\n        dirpath_and_fpath_walker,\n        generate_comment_path,\n        construct_llm_and_write_code_comment,\n    )\n    return param\nfrom jinja2 import Environment, FileSystemLoader, Template\n@beartype\nclass SearchIndexData(dict):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.counter = 0\n        self.file_id: Optional[int] = None\n    def insert_filepath_and_summary(self, file_id: int, filepath: str, summary: str):\n        self.file_id = file_id\n        self.insert(\n            content=filepath,\n            type=\"filepath\",\n        )\n        self.insert(\n            content=summary,\n            type=\"summary\",\n        )\n    def insert_code_and_comment(self, code: str, comment: str, location: str):\n        self.insert(content=code, type=\"code\", location=location)\n        self.insert(\n            content=comment,\n            type=\"comment\",\n        )\n    def insert(\n        self,\n        content: str,\n        type: Literal[\"filepath\", \"summary\", \"comment\", \"code\"],\n        location: Optional[str] = None,"
        },
        {
            "comment": "The code is a recursive document writer that stores data in an iterable object and increments the counter for each entry. It also includes a function to render a webpage using a template engine, loading templates from a specified directory and generating HTML output based on the input parameters.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":113-146",
            "content": "    ):\n        assert isinstance(self.file_id, int)\n        self[self.counter] = dict(\n            file_id=self.file_id,\n            content=content,\n            type=type,\n            **(dict(location=location) if location else {}),\n        )\n        self.counter += 1\n@beartype\ndef render_document_webpage(\n    document_dir_path: str,\n    param: SourceIteratorAndTargetGeneratorParam,\n    repository_url: str,\n    template_dir: str = \".\",\n    template_filename: str = \"website_template.html.j2\",\n    output_filename: str = \"index.html\",\n    url_prefix: str = \"https://github.com/\",\n):\n    @beartype\n    def load_template() -> Template:\n        # Load the template from file\n        file_loader = FileSystemLoader(\n            template_dir\n        )  # Replace 'path_to_templates_directory' with the actual path\n        env = Environment(loader=file_loader)\n        template = env.get_template(\n            template_filename\n        )  # Replace 'sitemap_template.html' with the actual template file name\n        return template\n    @beartype"
        },
        {
            "comment": "This code defines a function `write_to_output_path` which takes content and writes it to an output path. The `get_template_render_params()` function returns a dictionary of template render parameters. It uses nested functions: `strip_path_prefix` and `strip_location` for handling file paths, and `update_data_by_target_data` for inserting data into the `SearchIndexData` object.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":147-173",
            "content": "    def write_to_output_path(content: str):\n        output_path = os.path.join(document_dir_path, output_filename)\n        write_file(output_path, content)\n    @beartype\n    def get_template_render_params() -> dict[str, Union[dict, str]]:\n        data = SearchIndexData()\n        file_mapping: dict[int, dict[str, Union[str, int]]] = {}\n        @beartype\n        def strip_path_prefix(path: str):\n            return path[len(param.source_dir_path) :]\n        @beartype\n        def strip_location(location: str):\n            result = parse.parse(CODE_LOCATION_FORMAT, location)\n            assert isinstance(result, parse.Result)\n            stripped_path = strip_path_prefix(result[\"code_path\"])\n            return f\"{stripped_path}:{result['line_start']+1}-{result['line_end']+1}\"\n        @beartype\n        def update_data_by_target_data(\n            target_data: dict, file_id: int, source_relative_path: str\n        ):\n            data.insert_filepath_and_summary(\n                file_id=file_id,\n                filepath=source_relative_path,"
        },
        {
            "comment": "This code defines a function `update_data_and_file_mapping` that takes a manager, record, file ID, and source relative path as inputs. It updates the file mapping by adding a new entry with the given parameters. It also retrieves target data from a JSON file and updates it accordingly. The code also includes a separate function `assemble_render_params` which extracts a partial repository URL from a provided URL prefix.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":174-197",
            "content": "                summary=target_data[\"summary\"],\n            )\n            for detail in target_data[\"details\"]:\n                data.insert_code_and_comment(\n                    code=detail[\"content\"],\n                    comment=detail[\"comment\"],\n                    location=strip_location(detail[\"location\"]),\n                )\n        @beartype\n        def update_data_and_file_mapping(\n            manager: CacheManager, record: dict, file_id: int, source_relative_path: str\n        ):\n            file_mapping[file_id] = dict(\n                filepath=source_relative_path,\n                entry_id=data.counter,\n                language_id=get_language_id_from_filename(source_relative_path),\n            )\n            target_path, _ = manager.get_record_target_path_and_hash(record)\n            target_data = json.loads(read_file(target_path))\n            update_data_by_target_data(target_data, file_id, source_relative_path)\n        def assemble_render_params():\n            partial_repository_url = repository_url.replace(url_prefix, \"\")"
        },
        {
            "comment": "This code defines a function that iterates through the source directory, assembles render parameters for each file, and sorts the file paths to reduce Git folder size. The function uses a CacheContextManager and checks if a record exists in the database for each source path.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":198-218",
            "content": "            render_params = dict(\n                datadict=data,\n                repository_url=repository_url,\n                file_mapping=file_mapping,\n                partial_repository_url=partial_repository_url,\n            )\n            return render_params\n        def iterate_source_dir_and_assemble_render_params():\n            # if only have one file, we should return one\n            with CacheContextManager(param.db_path) as manager:\n                source_path_list = [\n                    sp for _, sp in dirpath_and_fpath_walker(param.source_dir_path)\n                ]\n                source_path_list.sort()  # to reduce git folder size\n                for file_id, source_path in enumerate(source_path_list):\n                    source_relative_path = strip_path_prefix(source_path)\n                    record, _ = manager.get_record_by_computing_source_hash(source_path)\n                    if record:\n                        update_data_and_file_mapping(\n                            manager, record, file_id, source_relative_path"
        },
        {
            "comment": "This code snippet defines a function `write_render_params` that takes in a dictionary of render parameters. The function extracts specific information from the provided dictionary, such as URLs, file mapping, and project name. This function is used for writing documentation and appears to be part of a larger system for documenting source files.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":219-249",
            "content": "                        )\n            return assemble_render_params()\n        return iterate_source_dir_and_assemble_render_params()\n    def strip_quote(s: str):\n        s = s.strip()\n        if s[0] == s[-1]:\n            if s[0] in ['\"', \"'\"]:\n                return s[1:-1].strip()\n        return s.strip()\n    @beartype\n    def write_render_params(render_params: dict):\n        # TODO: mapping source file path to documentation json\n        # TODO: add mode of index to hide search bar and render single file left-right comparison only\n        datadict = render_params[\"datadict\"]\n        metadata = dict()\n        metadata[\"url\"] = dict(\n            full=render_params[\"repository_url\"],\n            partial=render_params[\"partial_repository_url\"],\n        )\n        metadata[\"file_mapping\"] = render_params[\"file_mapping\"]\n        metadata[\"project_name\"] = render_params[\"partial_repository_url\"].split(\"/\")[\n            -1\n        ]\n        split_count = 0\n        # datadict_split = {}\n        datadict = {\n            k: v"
        },
        {
            "comment": "Code generates JSON data chunks from a given dictionary and saves them into separate files within a \"data\" directory. It also creates a \"metadata.json\" file containing the total number of generated data chunks. The code handles directories' creation if they do not exist, and the function render_template is called with Template parameter which seems to be related to rendering templates.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":250-278",
            "content": "            if (v[\"type\"] not in [\"comment\", \"summary\"])\n            else {\n                \"file_id\": v[\"file_id\"],\n                \"content\": strip_quote(v[\"content\"]),\n                \"type\": v[\"type\"],\n            }\n            for k, v in datadict.items()\n        }\n        data_dir = os.path.join(document_dir_path, \"data\")\n        if not os.path.exists(data_dir):\n            os.mkdir(data_dir)\n        for chunk in split_dict_into_chunks(datadict, DATA_SLICE_LENGTH):\n            write_file(\n                os.path.join(data_dir, f\"{split_count}.json\"),\n                json.dumps(chunk, indent=4, ensure_ascii=False),\n            )\n            split_count += 1\n        metadata[\"split_count\"] = split_count\n        write_file(\n            os.path.join(document_dir_path, \"metadata.json\"),\n            json.dumps(metadata, indent=4, ensure_ascii=False),\n        )\n    @beartype\n    def render_template(template: Template):\n        render_params = get_template_render_params()\n        write_render_params(render_params)"
        },
        {
            "comment": "This code contains various helper functions for rendering a template, copying static files, and creating a gitignore file. The main function `render_to_output_path` combines these operations to render the template, copy static pages, and create a gitignore file at the specified document directory path.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":279-309",
            "content": "        # do something else, like writing to files.\n        # ret = template.render(**render_params)\n        # return ret\n    def copy_static_pages():\n        script_base_dir = os.path.split(__file__)[0]\n        static_pages_dir = os.path.join(script_base_dir, \"static_pages\")\n        for fname in [\"index.html\", \"codeview.html\"]:\n            # for fname in os.listdir(static_pages_dir):\n            shutil.copy(os.path.join(static_pages_dir, fname), document_dir_path)\n    def write_gitignore():\n        with open(os.path.join(document_dir_path, \".gitignore\"), \"w+\") as f:\n            f.write(\"!.gitignore\\n!*\\n!*/*\\ncache_db.json\\ncache_tree.json\\nvector_cache\\n\")\n            # f.write(\"!.gitignore\\n!*\\n!*/*\\ncache_db.json\\n\")\n    def render_to_output_path():\n        template = load_template()\n        render_template(template)\n        copy_static_pages()\n        write_gitignore()\n        # content = render_template(template)\n        # write_to_output_path(content)\n    render_to_output_path()\nimport subprocess\ndef run_subprocess(cli: str):"
        },
        {
            "comment": "This code executes a series of subprocess commands to generate and manipulate documentation for a project. It starts by parsing arguments, setting custom document writer parameters, scanning the code directory, writing to the comment directory, and rendering a webpage. Finally, it runs multiple subprocesses to generate a tree view, title generator, and sitemap generator for the project's documentation.",
            "location": "\"/media/root/Toshiba XG3/works/prometheous_doc/src/document_agi_computer_control/recursive_document_writer.py\":310-332",
            "content": "    print(\"running:\", cli)\n    excode = subprocess.check_call(cli, shell=True)\n    if excode != 0:\n        exit(excode)\ndef main():\n    (document_dir_path, repository_url) = parse_arguments()\n    project_name = repository_url.split(\"/\")[-1]\n    custom_doc_writer.CUSTOM_DOC_WRITER_PARAMS[\"location_prefix\"] = document_dir_path\n    custom_doc_writer.CUSTOM_DOC_WRITER_PARAMS[\"project_name\"] = project_name\n    param = scan_code_dir_and_write_to_comment_dir(document_dir_path)\n    # not done yet. we have to create the webpage.\n    render_document_webpage(document_dir_path, param, repository_url)\n    run_subprocess(\n        f\"python3 -u tree_markdown_view_folder_hierarchy/main_recursive.py -s '{document_dir_path}'\"\n    )\n    run_subprocess(f\"python3 -u title_generator/main.py -s '{document_dir_path}'\")\n    run_subprocess(f\"python3 -u sitemap_generator/main.py -s '{document_dir_path}'\")\nif __name__ == \"__main__\":\n    main()"
        }
    ]
}