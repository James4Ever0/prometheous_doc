{
    "300": {
        "file_id": 24,
        "content": "                    if banner_refresh_counter > 1:\n                    # if banner_refresh_counter > 10000:\n                        banner_refresh_counter = 0\n                        running = format_timedelta(datetime.now() - self.previous_time)\n                        self.label.renderable = Text.assemble((f\"Processing time: -/{self.previous_processing_time_by_line} (lines) -/{self.previous_processing_time_by_size} (size)\\nLines: -/{self.previous_line_count} Size: -/{self.previous_selected_size} Count: -/{self.previous_selected_count} Errors: -/{self.previous_error_count}\\nLast selection: {self.previous_selection_formatted} Selection: -/{self.previous_selection}\\nTotal size: {humanize.naturalsize(self.filesize)}/{self.previous_filesize} Total count: {self.total_count}/{self.previous_total_count} Errors: {self.error_size_count}/{self.previous_error_size_count}\\nLast scanning: {self.previous_scanning_formatted} Scanning: {running}/{self.previous_scanning}\", \"bold\"))\n                        self.label.refresh()",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/main_pyjom.py:425-430"
    },
    "301": {
        "file_id": 24,
        "content": "The code checks if banner refresh counter is greater than 1, and if so, updates the counter to 0 and calculates processing time. It then updates the label with relevant information like processing times, line counts, errors, selection, file size, total count, and scanning status. Finally, it refreshes the label.",
        "type": "comment"
    },
    "302": {
        "file_id": 24,
        "content": "                if self.loop_break:\n                    try:\n                        process2.terminate()\n                    except:\n                        pass\n                else:\n                    map_keys = numpy.array(list(self.mymap.keys()))\n                    remove_keys = numpy.setdiff1d(map_keys, numpy.array(list(self.existing_paths)))\n                    # breakpoint()\n                    # with open('remove_keys.txt', 'w+') as f:\n                    #     f.write(str(remove_keys))\n                    #     self.exit()\n                    for k in remove_keys:\n                        try:\n                            self.mymap[k].remove()\n                        except:\n                            pass\n                        finally:\n                            del self.mymap[k]\n                    self.previous_existing_paths = self.existing_paths\n                    self.previous_total_count = self.total_count\n                    self.previous_filesize = humanize.naturalsize(self.filesize)",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/main_pyjom.py:431-453"
    },
    "303": {
        "file_id": 24,
        "content": "The code checks if a loop has been interrupted, then terminates the process if it was. If not, it finds the differences between map keys and existing paths, removes corresponding files, updates variables, and prepares for next iteration.",
        "type": "comment"
    },
    "304": {
        "file_id": 24,
        "content": "                    self.previous_error_size_count = self.error_size_count\n                    self.previous_scanning = format_timedelta(datetime.now() - self.previous_time)\n                    self.previous_scanning_formatted = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                    self.previous_time = datetime.now()\n                await process2.wait()\n                # clear nonexisting paths\n                await asyncio.sleep(SLEEP)\n            processingLock.release()\n        # self.counter += 1\n    def compose(self) -> ComposeResult:\n        \"\"\"Create child widgets for the app.\"\"\"\n        return [self.header, self.treeview, self.label, self.footer]\n    def on_mount(self) -> None:\n        self.timer = self.set_interval(INTERVAL, self.progress)\n    def action_toggle_dark(self) -> None:\n        \"\"\"An action to toggle dark mode.\"\"\"\n        self.dark = not self.dark\n    def action_exit(self):\n        \"\"\"An action to exit the app.\"\"\"\n        self.exit()\ndef main():\n    diffpath = parse_args()\n    app = VisualIgnoreApp(diffpath)",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/main_pyjom.py:454-484"
    },
    "305": {
        "file_id": 24,
        "content": "This code segment appears to be related to a Python program handling file selectors, with functions for composing the user interface, setting timers for progress checks, and actions like toggling dark mode or exiting the app. The main function takes an argument, likely a path, and instantiates an instance of VisualIgnoreApp.",
        "type": "comment"
    },
    "306": {
        "file_id": 24,
        "content": "    app.run()\nif __name__ == \"__main__\":\n    main()",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/main_pyjom.py:485-489"
    },
    "307": {
        "file_id": 24,
        "content": "The code initiates a Flask application and starts the server, running it only when the script is executed directly (not imported).",
        "type": "comment"
    },
    "308": {
        "file_id": 25,
        "content": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/run_simple.py",
        "type": "filepath"
    },
    "309": {
        "file_id": 25,
        "content": "The code imports libraries, defines a script template for comparing file trees with and without ignore rules, parses command-line arguments, renders the script, writes to a temporary file, and runs the bash script, creating JSON files and calling display_tree_structure.py.",
        "type": "summary"
    },
    "310": {
        "file_id": 25,
        "content": "from tempfile import TemporaryDirectory\nfrom jinja2 import Template\nfrom argparse import ArgumentParser\nfrom beartype import beartype\nimport os\nimport subprocess\nscript_template_str = \"\"\"\ncd \"{{diffpath}}\"\nfd --no-ignore --hidden | tree --fromfile -J > \"{{tempdir}}/all_tree.json\"\nfd | tree --fromfile -J > \"{{tempdir}}/selected_tree.json\"\n\"\"\"\n# tree output in json\n# load tree json, set selected & unselected properties\n# count file size\n# render tree json\nscript_template = Template(script_template_str)\nRELATIVE_TEMP_DIR_SCRIPT_PATH = \"script.sh\"\ndef parse_args():\n    parser = ArgumentParser()\n    parser.add_argument(\"-d\", \"--diffpath\", help=\"Path to visualize ignored files\")\n    args = parser.parse_args()\n    return args.diffpath\n@beartype\ndef render_script_template(diffpath: str, tempdir: str) -> str:\n    return script_template.render(diffpath=diffpath, tempdir=tempdir)\nwith TemporaryDirectory() as tempdir:\n    diffpath = parse_args()\n    script_str = render_script_template(diffpath, tempdir)\n    with open(os.path.join(tempdir, RELATIVE_TEMP_DIR_SCRIPT_PATH), \"w\") as f:",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/run_simple.py:1-39"
    },
    "311": {
        "file_id": 25,
        "content": "This code imports necessary libraries, defines a script template for comparing file trees with and without ignore rules, parses command-line arguments, renders the script template, and writes the resulting script to a temporary file.",
        "type": "comment"
    },
    "312": {
        "file_id": 25,
        "content": "        f.write(script_str)\n    subprocess.run([\"bash\", os.path.join(tempdir, RELATIVE_TEMP_DIR_SCRIPT_PATH)])\n    full = f\"{tempdir}/all_tree.json\"\n    selected = f\"{tempdir}/selected_tree.json\"\n    basepath = os.path.abspath(diffpath)\n    subprocess.run(\n        [\n            \"python3\",\n            \"display_tree_structure.py\",\n            \"--full\",\n            full,\n            \"--selected\",\n            selected,\n            \"--basepath\",\n            basepath,\n        ]\n    )",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/run_simple.py:40-56"
    },
    "313": {
        "file_id": 25,
        "content": "Writing script to file, running bash script in tempdir, creating full and selected JSON files, then calling display_tree_structure.py with arguments.",
        "type": "comment"
    },
    "314": {
        "file_id": 26,
        "content": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/test_tree_visual.py",
        "type": "filepath"
    },
    "315": {
        "file_id": 26,
        "content": "The code imports modules, defines functions for asynchronous execution and comparison, and sets up a user interface with label widgets, progress function, dark mode toggle, and application exit. The main function initializes VisualIgnoreApp and runs the application.",
        "type": "summary"
    },
    "316": {
        "file_id": 26,
        "content": "# from rich.tree import Tree\nfrom textual.app import App, ComposeResult\nfrom textual.widgets import Header, Footer, Label, Tree\nfrom rich.text import Text\nfrom textual.timer import Timer\nfrom threading import Lock\nimport subprocess\n# from tempfile import TemporaryDirectory\nfrom jinja2 import Template\nfrom argparse import ArgumentParser\nfrom beartype import beartype\nINTERVAL = 3\nimport asyncio\nasync def run_command(command:str):\n    process = await asyncio.create_subprocess_shell(\n        command,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n    stdout, stderr = await process.communicate()\n    return stdout.decode().strip(), stderr.decode().strip()\nscript_template_str = \"\"\"\ncd \"{{diffpath}}\"\nfd --no-ignore --hidden | tree --fromfile > \"{{tempdir}}/all_tree.txt\"\nfd | tree --fromfile > \"{{tempdir}}/selected_tree.txt\"\ndiff -y \"{{tempdir}}/all_tree.txt\" \"{{tempdir}}/selected_tree.txt\" > \"{{tempdir}}/diff_tree.txt\"\ncat \"{{tempdir}}/diff_tree.txt\"\n\"\"\"\n# tree output in json\n# load tree json, set selected & unselected properties",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/test_tree_visual.py:1-35"
    },
    "317": {
        "file_id": 26,
        "content": "This code imports necessary modules and defines a function to execute commands asynchronously. It also contains a template string for generating a script to compare two directories using the 'fd' and 'tree' commands, and then diffing their output. The purpose is to generate JSON representation of file trees and compare selected and unselected properties.",
        "type": "comment"
    },
    "318": {
        "file_id": 26,
        "content": "# count file size\n# render tree json\nscript_template = Template(script_template_str)\nRELATIVE_TEMP_DIR_SCRIPT_PATH = \"script.sh\"\ndef parse_args():\n    parser = ArgumentParser()\n    parser.add_argument(\"-d\", \"--diffpath\", help=\"Path to visualize ignored files\")\n    args = parser.parse_args()\n    return args.diffpath\n@beartype\ndef render_script_template(diffpath: str, tempdir: str) -> str:\n    return script_template.render(diffpath=diffpath, tempdir=tempdir)\nprocessingLock = Lock()\nclass VisualIgnoreApp(App):\n    \"\"\"A Textual app to visualize ignore files.\"\"\"\n    BINDINGS = [(\"d\", \"toggle_dark\", \"Toggle dark mode\"), (\"e\", \"exit\", \"Exit\")]\n    timer: Timer\n    def __init__(self, diffpath, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.i = 0\n        self.header = Header()\n        self.diffpath = diffpath\n        self.treeview = Tree(\".\")\n        self.treeview.root.expand()\n        # self.treeview = RichLog(auto_scroll=False)\n        self.footer = Footer()\n        # self.mytree = Tree(\".\")\n        self.label = Label(Text.assemble((\"ETA:\", \"bold\")), expand=True)",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/test_tree_visual.py:36-75"
    },
    "319": {
        "file_id": 26,
        "content": "This code sets up an application for visualizing ignored files. It defines a template to generate a script, parses command-line arguments, and initializes the VisualIgnoreApp class with necessary attributes such as treeview and footer. The app has bindings for toggling dark mode and exiting.",
        "type": "comment"
    },
    "320": {
        "file_id": 26,
        "content": "        self.label.styles.background = \"red\"\n        # self.label.styles.border = ('solid','red')\n        # self.label.styles.height = 3\n        self.label.styles.height = 1\n        # self.label.styles.dock = 'bottom'\n    async def progress(self):\n        locked = processingLock.acquire(blocking=False)\n        if locked: # taking forever. bad.\n            self.treeview.root.set_label(str(self.i))\n            self.i+=1\n            self.treeview.root.add(\"item\", expand=True)\n            # self.treeview.refresh()\n            processingLock.release()\n        # self.counter += 1\n    def compose(self) -> ComposeResult:\n        \"\"\"Create child widgets for the app.\"\"\"\n        return [self.header, self.treeview, self.label, self.footer]\n    def on_mount(self) -> None:\n        self.timer = self.set_interval(INTERVAL, self.progress)\n    def action_toggle_dark(self) -> None:\n        \"\"\"An action to toggle dark mode.\"\"\"\n        self.dark = not self.dark\n    def action_exit(self):\n        \"\"\"An action to exit the app.\"\"\"\n        self.exit()",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/test_tree_visual.py:76-107"
    },
    "321": {
        "file_id": 26,
        "content": "This code is creating a user interface for an application. It sets the background color, height, and other styles for a label widget. The code also defines a progress function that updates a treeview with new items at regular intervals until it's locked by processingLock. It creates child widgets in the compose method, starts a timer to call the progress function, and provides actions to toggle dark mode and exit the application.",
        "type": "comment"
    },
    "322": {
        "file_id": 26,
        "content": "def main():\n    diffpath = parse_args()\n    app = VisualIgnoreApp(diffpath)\n    app.run()\nif __name__ == \"__main__\":\n    main()",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/test_tree_visual.py:110-117"
    },
    "323": {
        "file_id": 26,
        "content": "Main function sets parse_args, creates VisualIgnoreApp instance with argument and runs the application.",
        "type": "comment"
    },
    "324": {
        "file_id": 27,
        "content": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py",
        "type": "filepath"
    },
    "325": {
        "file_id": 27,
        "content": "The code imports libraries, defines functions for tree operations and argument parsing, creates/updates a tree structure, loads JSON files, computes total file size and selected counts by suffix, estimates processing time using defaultdicts.",
        "type": "summary"
    },
    "326": {
        "file_id": 27,
        "content": "from rich.text import Text\nfrom rich.console import Console\nimport datetime\n# color from:\nfrom rich.color import ANSI_COLOR_NAMES\nfrom collections import defaultdict\nconsole = Console()\nfrom rich.tree import Tree\nfrom rich import print\nimport json\nimport os\nimport humanize\nerror_map = defaultdict(list)\ncached_verified = []\ndef patch_missing_files(path, basemap, color, processor=lambda x: x):\n    subpath, filename = dirsplit(path)\n    # breakpoint()\n    if basemap.get(path) is None:\n        subtree = patch_missing_files(subpath + \"/\", basemap, color)\n        subsubtree = subtree.add(processor(filename), style=color, guide_style=color)\n        # print(filename)\n        basemap[path] = subsubtree\n        return subsubtree\n    else:\n        return basemap.get(path)\ndef size_to_readable_string(size: int):\n    return humanize.naturalsize(size)\nGREY = \"bright_black\"\nimport argparse\nparser = argparse.ArgumentParser()\nparser.add_argument(\"--full\", help=\"full tree\", type=str, required=True)\nparser.add_argument(\"--selected\", help=\"selected tree\", type=str, required=True)",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:1-44"
    },
    "327": {
        "file_id": 27,
        "content": "This code imports several libraries and defines functions to work with tree structures. It uses colors, console output, and file operations. The `patch_missing_files` function creates or updates a tree structure based on file paths, while the `size_to_readable_string` function converts byte sizes to human-readable format. The code also sets up an argument parser for command line arguments.",
        "type": "comment"
    },
    "328": {
        "file_id": 27,
        "content": "parser.add_argument(\"--basepath\", help=\"path to the base\", type=str, required=True)\nargs = parser.parse_args()\nfull_json = args.full\nselected_json = args.selected\nbasepath = args.basepath\nassert os.path.isabs(basepath)\nbasepath = os.path.abspath(basepath)\ntree_data = json.load(open(full_json))\nselected_json = json.load(open(selected_json))  # could be different.\ncached_paths = [\n    \"/media/root/Toshiba XG3/works/prometheous/document_agi_computer_control/recursive_document_writer.py\",\n    \"/media/root/Toshiba XG3/works/prometheous/document_agi_computer_control/code_view_with_path_argument_and_anchor/code_view_demo.py\",\n]\nfor p in cached_paths:\n    assert os.path.isabs(p)\ncached_paths = [os.path.abspath(p) for p in cached_paths]\nfor p in cached_paths:\n    assert os.path.commonprefix([p, basepath]) == basepath\nsize_map = {}\nselected_keys = []\nexisting_keys = []\n# Add the tree contents recursively\ndef add_tree_contents(parent, contents, basedir=\".\", basemap={}):\n    for item in contents:\n        if item[\"type\"] == \"directory\":",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:45-79"
    },
    "329": {
        "file_id": 27,
        "content": "This code parses command line arguments, loads JSON files, and checks paths for absolute references. It then adds the tree contents recursively to a size map.",
        "type": "comment"
    },
    "330": {
        "file_id": 27,
        "content": "            # subtree = parent.add(f\"[bold]{item['name']}\")\n            # subtree = parent.add(\n            #     Text.assemble((item[\"name\"], \"bold\")),\n            #     style=GREY,\n            #     guide_style=GREY,\n            # )\n            subtree = patch_missing_files(\n                os.path.join(basedir, item[\"name\"] + \"/\"),\n                basemap,\n                GREY,\n                lambda x: Text.assemble((x, \"bold\")),\n            )\n            existing_keys.append(os.path.join(basedir, item[\"name\"] + \"/\"))\n            # basemap[os.path.join(basedir, item[\"name\"] + \"/\")] = subtree\n            dirfs = 0\n            for fs in add_tree_contents(\n                subtree,\n                item.get(\"contents\", []),\n                os.path.join(basedir, item[\"name\"]),\n                basemap,\n            ):\n                dirfs += fs\n                yield fs\n            size_map[os.path.join(basedir, item[\"name\"] + \"/\")] = dirfs\n        else:  # file\n            # subtree = parent.add(item['name'])\n            existing_keys.append(os.path.join(basedir, item[\"name\"]))",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:80-106"
    },
    "331": {
        "file_id": 27,
        "content": "Creates a subtree for each directory item with name and style, updates size map, skips if file or adds tree contents recursively.",
        "type": "comment"
    },
    "332": {
        "file_id": 27,
        "content": "            filesize = os.path.getsize(\n                os.path.join(basepath, os.path.join(basedir, item[\"name\"]))\n            )\n            size_map[os.path.join(basedir, item[\"name\"])] = filesize\n            filesize_human = size_to_readable_string(filesize)\n            # subtree = patch_missing_files(os.path.join(basedir, item[\"name\"]),basemap, GREY, lambda x: f\"[{filesize_human}] \" + x)\n            subtree = parent.add(f\"[{filesize_human}] \" + item[\"name\"], style=GREY)\n            basemap[os.path.join(basedir, item[\"name\"])] = subtree\n            yield filesize\ndef dirsplit(path):\n    if path.endswith(\"/\"):\n        path = path[:-1]\n    return os.path.split(path)\ndef set_path_to_white(path, basemap):\n    subtree = patch_missing_files(path, basemap, \"white\")\n    subtree.style = \"white\"\n    subtree.guide_style = \"white\"\n    return subtree\nselected_dirs = []\nline_map = {}\n# can have missing files.\ndef iterate_all_keys(contents, basemap, basedir=\".\"):\n    for item in contents:\n        if item[\"type\"] == \"directory\":",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:107-139"
    },
    "333": {
        "file_id": 27,
        "content": "This code is iterating over the contents of a directory, identifying directories and files, and creating a tree-like visual representation. It also handles missing files by setting their color to white and updating their style accordingly. The selected directories and line map are stored for further use.",
        "type": "comment"
    },
    "334": {
        "file_id": 27,
        "content": "            subpaths = item.get(\"contents\", [])\n            if subpaths:\n                dirlc = 0\n                cached_count = 0\n                # total_lc = 0\n                for lc in iterate_all_keys(\n                    subpaths, basemap, os.path.join(basedir, item[\"name\"])\n                ):\n                    # total_lc +=1\n                    if lc == -3:\n                        cached_count += 1\n                        continue\n                    dirlc += lc\n                    yield lc\n                if dirlc != 0:\n                    selected_dirs.append(os.path.join(basedir, item[\"name\"] + \"/\"))\n                    set_path_to_white(\n                        os.path.join(basedir, item[\"name\"] + \"/\"), basemap\n                    )\n                    line_map[os.path.join(basedir, item[\"name\"] + \"/\")] = dirlc\n                elif len(subpaths) == cached_count:\n                    # elif total_lc == cached_count:\n                    subtree = set_path_to_white(\n                        os.path.join(basedir, item[\"name\"] + \"/\"), basemap",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:140-163"
    },
    "335": {
        "file_id": 27,
        "content": "Iterates over subpaths of the item and counts the number of directories and cached files. If the count is non-zero, adds the directory path to selected_dirs and updates line_map. If all subpaths are cached, sets the subtree path as white in basemap.",
        "type": "comment"
    },
    "336": {
        "file_id": 27,
        "content": "                    )\n                    subtree.label = f\"[Cached] \" + item[\"name\"]\n                    cached_verified.append(os.path.join(basedir, item[\"name\"] + \"/\"))\n        else:  # file\n            # breakpoint()\n            selected_keys.append(os.path.join(basedir, item[\"name\"]))\n            linecount = read_file_and_get_line_count(\n                os.path.join(basepath, os.path.join(basedir, item[\"name\"]))\n            )\n            line_map[os.path.join(basedir, item[\"name\"])] = linecount\n            subtree = set_path_to_white(os.path.join(basedir, item[\"name\"]), basemap)\n            error = True\n            if linecount == 0:\n                label = \"Empty\"\n            elif linecount == -1:\n                label = \"Missing\"\n            elif linecount == -2:\n                label = \"Error\"\n            elif linecount == -3:\n                label = \"Cached\"\n                error = False\n                cached_verified.append(os.path.join(basedir, item[\"name\"]))\n            else:\n                label = f\"{linecount} L\"",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:164-188"
    },
    "337": {
        "file_id": 27,
        "content": "This code adds a file or directory to the tree, sets the label and handles various scenarios: empty, missing, error, cached. It also verifies if the file is cached in some cases and keeps track of line counts for files.",
        "type": "comment"
    },
    "338": {
        "file_id": 27,
        "content": "                error = False\n            if error:\n                error_map[os.path.join(basedir, item[\"name\"])].append(label)\n            else:\n                yield linecount\n            subtree.label = f\"[{label}] \" + item[\"name\"]\ndef read_file_and_get_line_count(filepath: str):\n    filepath = os.path.abspath(filepath)\n    if not os.path.exists(filepath):\n        return -1\n    if filepath in cached_paths:\n        return -3\n    try:\n        with open(filepath, \"r\") as f:\n            lines = f.readlines()\n            return len(lines)\n    except:\n        return -2\nselected_keys = []\ndef get_selected_keys(tree_data, basemap):\n    iterate_all_keys(tree_data[0].get(\"contents\", []), basemap)\n    return selected_keys\ntree = Tree(\".\")\n# tree = Tree(\"agi_computer_control\", style=GREY, guide_style=GREY)\nroot = tree_data[0]  # Assuming the first item in the JSON is the root directory\nmymap = {\"./\": tree}\nexisting_keys.append(\"./\")\ntotal_size = sum(add_tree_contents(tree, root.get(\"contents\", []), basemap=mymap))\nnonexist_keys = [k for k in mymap.keys() if k not in existing_keys]",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:189-226"
    },
    "339": {
        "file_id": 27,
        "content": "Code is reading a file path and counting its lines. It checks if the file exists, if it's already in the cache, and then attempts to open and read the file. If any error occurs, it appends a label to an error map. The code also creates a tree structure and gets selected keys from the tree data using a helper function iterate_all_keys(). It calculates the total size of the contents of the directory and collects nonexist keys.",
        "type": "comment"
    },
    "340": {
        "file_id": 27,
        "content": "for key in nonexist_keys:\n    it = mymap.get(key, None)\n    if it is not None:\n        parent, child = dirsplit(key)\n        parent_it = mymap.get(parent + \"/\", None)\n        if parent_it is not None:\n            parent_it.children.remove(it)\n        del mymap[key]\ntotal_lines = sum(iterate_all_keys(selected_json[0].get(\"contents\", []), mymap))\n# Print the tree\nsize_map[\"./\"] = total_size\nif total_lines != 0:\n    selected_dirs.append(\"./\")\n    line_map[\"./\"] = total_lines\ntree.label = Text.assemble(\n    (\n        (\n            f\"[{total_lines} L] \"\n            if total_lines != 0\n            else f\"[{size_to_readable_string(total_size)}] \"\n        )\n        + tree.label,\n        \"magenta\",\n    )\n)\ndef estimate_time_from_lines(line_count: int):\n    seconds = (line_count / 10) * 100\n    return humanize.naturaltime(datetime.timedelta(seconds=seconds)).split(\" ago\")[0]\nfor k, v in mymap.items():\n    if k.endswith(\"/\"):\n        _, name = dirsplit(k)\n        if k in cached_verified:\n            continue\n        elif k in selected_dirs:",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:228-268"
    },
    "341": {
        "file_id": 27,
        "content": "Iterating through nonexist_keys to update the mymap dictionary with parent-child relationships, counting total size and lines for the current directory, updating tree labels accordingly.",
        "type": "comment"
    },
    "342": {
        "file_id": 27,
        "content": "            v.label = f\"[{line_map[k]} L] \" + name\n            # v.label = f\"[{estimate_time_from_lines(line_map[k])}] \"+ name\n        else:\n            v.label = f\"[{size_to_readable_string(size_map[k])}] \" + name\nconsole = Console()\nconsole.print(tree)\n# total_size = sum(size_map.values())\nselected_size = sum(size_map[k] for k in selected_keys)\n# make mapping between displayed tree and actual tree\nprint(\n    dict(\n        total=size_to_readable_string(total_size),\n        selected=size_to_readable_string(selected_size),\n    )\n)\n# total_lines = sum(line_map.values())\nprint(dict(selected_lines=humanize.intword(total_lines) + \" lines\"))\nprocessing_time = estimate_time_from_lines(total_lines)\nprint(dict(processing_time=processing_time))\ntotal_size_by_suffix = defaultdict(int)\nfilecount_by_suffix = defaultdict(int)\nfor k, v in size_map.items():\n    suffix = os.path.split(k)[1].split(\".\")[-1]\n    if suffix == \"\":\n        suffix = \"<no suffix>\"\n    total_size_by_suffix[suffix] += v\n    filecount_by_suffix[suffix] += 1",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:269-300"
    },
    "343": {
        "file_id": 27,
        "content": "Code calculates and displays the total and selected sizes in readable format, the number of lines, and processing time estimate. It also creates defaultdicts to count file sizes and counts by suffix.",
        "type": "comment"
    },
    "344": {
        "file_id": 27,
        "content": "lines_by_suffix = defaultdict(int)\nselected_filecount_by_suffix = defaultdict(int)\nfor k in selected_keys:\n    suffix = os.path.split(k)[1].split(\".\")[-1]\n    if suffix == \"\":\n        suffix = \"<no suffix>\"\n    selected_filecount_by_suffix[suffix] += 1\n    v = line_map[k]\n    lines_by_suffix[suffix] += v\nprint(\n    dict(\n        total={k: size_to_readable_string(v) for k, v in total_size_by_suffix.items()},\n        # total=set(os.path.split(it)[1].split(\".\")[-1] for it in size_map.keys()),\n        selected={\n            k: humanize.intword(v) + \" lines\" for k, v in lines_by_suffix.items()\n        },\n    )\n)\nprint(dict(total=filecount_by_suffix, selected=selected_filecount_by_suffix))\nprint(\"error:\", {k: len(v) for k, v in error_map.items()})\n# print(mymap)",
        "type": "code",
        "location": "/document_agi_computer_control/visual_file_selector_by_ignore_rules/tree_utils.py:301-321"
    },
    "345": {
        "file_id": 27,
        "content": "Calculating and printing total file size, selected lines by suffix, and error count.",
        "type": "comment"
    },
    "346": {
        "file_id": 28,
        "content": "/search_filepath_by_name/search_filepath.sh",
        "type": "filepath"
    },
    "347": {
        "file_id": 28,
        "content": "Searching for files using fzf in the current directory.",
        "type": "summary"
    },
    "348": {
        "file_id": 28,
        "content": "# plan to do this on webpage.\n# will webpage handle this well? not going to crash?\ncd ../\nfd -u | fzf",
        "type": "code",
        "location": "/search_filepath_by_name/search_filepath.sh:1-6"
    },
    "349": {
        "file_id": 28,
        "content": "Searching for files using fzf in the current directory.",
        "type": "comment"
    }
}